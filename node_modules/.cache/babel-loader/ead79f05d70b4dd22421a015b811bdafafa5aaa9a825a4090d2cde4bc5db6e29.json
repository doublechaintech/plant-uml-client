{"ast":null,"code":"/*\n * $Id: rawinflate.js,v 0.2 2009/03/01 18:32:24 dankogai Exp $\n *\n * original:\n * http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt\n */\n\n/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0.0.1\n * LastModified: Dec 25 1999\n */\n\n/* Interface:\n * data = inflate(src);\n */\n\n(function () {\n  /* constant parameters */\n  var WSIZE = 32768,\n    // Sliding Window size\n    STORED_BLOCK = 0,\n    STATIC_TREES = 1,\n    DYN_TREES = 2,\n    /* for inflate */\n    lbits = 9,\n    // bits in base literal/length lookup table\n    dbits = 6,\n    // bits in base distance lookup table\n\n    /* variables (inflate) */\n    slide,\n    wp,\n    // current position in slide\n    fixed_tl = null,\n    // inflate static\n    fixed_td,\n    // inflate static\n    fixed_bl,\n    // inflate static\n    fixed_bd,\n    // inflate static\n    bit_buf,\n    // bit buffer\n    bit_len,\n    // bits in bit buffer\n    method,\n    eof,\n    copy_leng,\n    copy_dist,\n    tl,\n    // literal length decoder table\n    td,\n    // literal distance decoder table\n    bl,\n    // number of bits decoded by tl\n    bd,\n    // number of bits decoded by td\n\n    inflate_data,\n    inflate_pos,\n    /* constant tables (inflate) */\n    MASK_BITS = [0x0000, 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff, 0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff],\n    // Tables for deflate from PKZIP's appnote.txt.\n    // Copy lengths for literal codes 257..285\n    cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],\n    /* note: see note #13 above about the 258 in this list. */\n    // Extra bits for literal codes 257..285\n    cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99 // 99==invalid\n    ],\n    // Copy offsets for distance codes 0..29\n    cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],\n    // Extra bits for distance codes\n    cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],\n    // Order of the bit length code lengths\n    border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n  /* objects (inflate) */\n\n  function HuftList() {\n    this.next = null;\n    this.list = null;\n  }\n  function HuftNode() {\n    this.e = 0; // number of extra bits or operation\n    this.b = 0; // number of bits in this code or subcode\n\n    // union\n    this.n = 0; // literal, length base, or distance base\n    this.t = null; // (HuftNode) pointer to next level of table\n  }\n\n  /*\n   * @param b-  code lengths in bits (all assumed <= BMAX)\n   * @param n- number of codes (assumed <= N_MAX)\n   * @param s- number of simple-valued codes (0..s-1)\n   * @param d- list of base values for non-simple codes\n   * @param e- list of extra bits for non-simple codes\n   * @param mm- maximum lookup bits\n   */\n  function HuftBuild(b, n, s, d, e, mm) {\n    this.BMAX = 16; // maximum bit length of any code\n    this.N_MAX = 288; // maximum number of codes in any set\n    this.status = 0; // 0: success, 1: incomplete table, 2: bad input\n    this.root = null; // (HuftList) starting table\n    this.m = 0; // maximum lookup bits, returns actual\n\n    /* Given a list of code lengths and a maximum table size, make a set of\n       tables to decode that set of codes. Return zero on success, one if\n       the given code set is incomplete (the tables are still built in this\n       case), two if the input is invalid (all zero length codes or an\n       oversubscribed set of lengths), and three if not enough memory.\n       The code with value 256 is special, and the tables are constructed\n       so that no bits beyond that code are fetched when that code is\n       decoded. */\n    var a; // counter for codes of length k\n    var c = [];\n    var el; // length of EOB code (value 256)\n    var f; // i repeats in table every f entries\n    var g; // maximum code length\n    var h; // table level\n    var i; // counter, current code\n    var j; // counter\n    var k; // number of bits in current code\n    var lx = [];\n    var p; // pointer into c[], b[], or v[]\n    var pidx; // index of p\n    var q; // (HuftNode) points to current table\n    var r = new HuftNode(); // table entry for structure assignment\n    var u = [];\n    var v = [];\n    var w;\n    var x = [];\n    var xp; // pointer into x or c\n    var y; // number of dummy codes added\n    var z; // number of entries in current table\n    var o;\n    var tail; // (HuftList)\n\n    tail = this.root = null;\n\n    // bit length count table\n    for (i = 0; i < this.BMAX + 1; i++) {\n      c[i] = 0;\n    }\n    // stack of bits per table\n    for (i = 0; i < this.BMAX + 1; i++) {\n      lx[i] = 0;\n    }\n    // HuftNode[BMAX][]  table stack\n    for (i = 0; i < this.BMAX; i++) {\n      u[i] = null;\n    }\n    // values in order of bit length\n    for (i = 0; i < this.N_MAX; i++) {\n      v[i] = 0;\n    }\n    // bit offsets, then code stack\n    for (i = 0; i < this.BMAX + 1; i++) {\n      x[i] = 0;\n    }\n\n    // Generate counts for each bit length\n    el = n > 256 ? b[256] : this.BMAX; // set length of EOB code, if any\n    p = b;\n    pidx = 0;\n    i = n;\n    do {\n      c[p[pidx]]++; // assume all entries <= BMAX\n      pidx++;\n    } while (--i > 0);\n    if (c[0] === n) {\n      // null input--all zero length codes\n      this.root = null;\n      this.m = 0;\n      this.status = 0;\n      return;\n    }\n\n    // Find minimum and maximum length, bound *m by those\n    for (j = 1; j <= this.BMAX; j++) {\n      if (c[j] !== 0) {\n        break;\n      }\n    }\n    k = j; // minimum code length\n    if (mm < j) {\n      mm = j;\n    }\n    for (i = this.BMAX; i !== 0; i--) {\n      if (c[i] !== 0) {\n        break;\n      }\n    }\n    g = i; // maximum code length\n    if (mm > i) {\n      mm = i;\n    }\n\n    // Adjust last length count to fill out codes, if needed\n    for (y = 1 << j; j < i; j++, y <<= 1) {\n      if ((y -= c[j]) < 0) {\n        this.status = 2; // bad input: more codes than bits\n        this.m = mm;\n        return;\n      }\n    }\n    if ((y -= c[i]) < 0) {\n      this.status = 2;\n      this.m = mm;\n      return;\n    }\n    c[i] += y;\n\n    // Generate starting offsets into the value table for each length\n    x[1] = j = 0;\n    p = c;\n    pidx = 1;\n    xp = 2;\n    while (--i > 0) {\n      // note that i == g from above\n      x[xp++] = j += p[pidx++];\n    }\n\n    // Make a table of values in order of bit lengths\n    p = b;\n    pidx = 0;\n    i = 0;\n    do {\n      if ((j = p[pidx++]) !== 0) {\n        v[x[j]++] = i;\n      }\n    } while (++i < n);\n    n = x[g]; // set n to length of v\n\n    // Generate the Huffman codes and for each, make the table entries\n    x[0] = i = 0; // first Huffman code is zero\n    p = v;\n    pidx = 0; // grab values in bit order\n    h = -1; // no tables yet--level -1\n    w = lx[0] = 0; // no bits decoded yet\n    q = null; // ditto\n    z = 0; // ditto\n\n    // go through the bit lengths (k already is bits in shortest code)\n    for (null; k <= g; k++) {\n      a = c[k];\n      while (a-- > 0) {\n        // here i is the Huffman code of length k bits for value p[pidx]\n        // make tables up to required level\n        while (k > w + lx[1 + h]) {\n          w += lx[1 + h]; // add bits already decoded\n          h++;\n\n          // compute minimum size table less than or equal to *m bits\n          z = (z = g - w) > mm ? mm : z; // upper limit\n          if ((f = 1 << (j = k - w)) > a + 1) {\n            // try a k-w bit table\n            // too few codes for k-w bit table\n            f -= a + 1; // deduct codes from patterns left\n            xp = k;\n            while (++j < z) {\n              // try smaller tables up to z bits\n              if ((f <<= 1) <= c[++xp]) {\n                break; // enough codes to use up j bits\n              }\n\n              f -= c[xp]; // else deduct codes from patterns\n            }\n          }\n\n          if (w + j > el && w < el) {\n            j = el - w; // make EOB code end at table\n          }\n\n          z = 1 << j; // table entries for j-bit table\n          lx[1 + h] = j; // set table size in stack\n\n          // allocate and link in new table\n          q = [];\n          for (o = 0; o < z; o++) {\n            q[o] = new HuftNode();\n          }\n          if (!tail) {\n            tail = this.root = new HuftList();\n          } else {\n            tail = tail.next = new HuftList();\n          }\n          tail.next = null;\n          tail.list = q;\n          u[h] = q; // table starts after link\n\n          /* connect to last table, if there is one */\n          if (h > 0) {\n            x[h] = i; // save pattern for backing up\n            r.b = lx[h]; // bits to dump before this table\n            r.e = 16 + j; // bits in this table\n            r.t = q; // pointer to this table\n            j = (i & (1 << w) - 1) >> w - lx[h];\n            u[h - 1][j].e = r.e;\n            u[h - 1][j].b = r.b;\n            u[h - 1][j].n = r.n;\n            u[h - 1][j].t = r.t;\n          }\n        }\n\n        // set up table entry in r\n        r.b = k - w;\n        if (pidx >= n) {\n          r.e = 99; // out of values--invalid code\n        } else if (p[pidx] < s) {\n          r.e = p[pidx] < 256 ? 16 : 15; // 256 is end-of-block code\n          r.n = p[pidx++]; // simple code is just the value\n        } else {\n          r.e = e[p[pidx] - s]; // non-simple--look up in lists\n          r.n = d[p[pidx++] - s];\n        }\n\n        // fill code-like entries with r //\n        f = 1 << k - w;\n        for (j = i >> w; j < z; j += f) {\n          q[j].e = r.e;\n          q[j].b = r.b;\n          q[j].n = r.n;\n          q[j].t = r.t;\n        }\n\n        // backwards increment the k-bit code i\n        for (j = 1 << k - 1; (i & j) !== 0; j >>= 1) {\n          i ^= j;\n        }\n        i ^= j;\n\n        // backup over finished tables\n        while ((i & (1 << w) - 1) !== x[h]) {\n          w -= lx[h]; // don't need to update q\n          h--;\n        }\n      }\n    }\n\n    /* return actual size of base table */\n    this.m = lx[1];\n\n    /* Return true (1) if we were given an incomplete table */\n    this.status = y !== 0 && g !== 1 ? 1 : 0;\n  }\n\n  /* routines (inflate) */\n\n  function GET_BYTE() {\n    if (inflate_data.length === inflate_pos) {\n      return -1;\n    }\n    return inflate_data[inflate_pos++] & 0xff;\n  }\n  function NEEDBITS(n) {\n    while (bit_len < n) {\n      bit_buf |= GET_BYTE() << bit_len;\n      bit_len += 8;\n    }\n  }\n  function GETBITS(n) {\n    return bit_buf & MASK_BITS[n];\n  }\n  function DUMPBITS(n) {\n    bit_buf >>= n;\n    bit_len -= n;\n  }\n  function inflate_codes(buff, off, size) {\n    // inflate (decompress) the codes in a deflated (compressed) block.\n    // Return an error code or zero if it all goes ok.\n    var e; // table entry flag/number of extra bits\n    var t; // (HuftNode) pointer to table entry\n    var n;\n    if (size === 0) {\n      return 0;\n    }\n\n    // inflate the coded data\n    n = 0;\n    for (;;) {\n      // do until end of block\n      NEEDBITS(bl);\n      t = tl.list[GETBITS(bl)];\n      e = t.e;\n      while (e > 16) {\n        if (e === 99) {\n          return -1;\n        }\n        DUMPBITS(t.b);\n        e -= 16;\n        NEEDBITS(e);\n        t = t.t[GETBITS(e)];\n        e = t.e;\n      }\n      DUMPBITS(t.b);\n      if (e === 16) {\n        // then it's a literal\n        wp &= WSIZE - 1;\n        buff[off + n++] = slide[wp++] = t.n;\n        if (n === size) {\n          return size;\n        }\n        continue;\n      }\n\n      // exit if end of block\n      if (e === 15) {\n        break;\n      }\n\n      // it's an EOB or a length\n\n      // get length of block to copy\n      NEEDBITS(e);\n      copy_leng = t.n + GETBITS(e);\n      DUMPBITS(e);\n\n      // decode distance of block to copy\n      NEEDBITS(bd);\n      t = td.list[GETBITS(bd)];\n      e = t.e;\n      while (e > 16) {\n        if (e === 99) {\n          return -1;\n        }\n        DUMPBITS(t.b);\n        e -= 16;\n        NEEDBITS(e);\n        t = t.t[GETBITS(e)];\n        e = t.e;\n      }\n      DUMPBITS(t.b);\n      NEEDBITS(e);\n      copy_dist = wp - t.n - GETBITS(e);\n      DUMPBITS(e);\n\n      // do the copy\n      while (copy_leng > 0 && n < size) {\n        copy_leng--;\n        copy_dist &= WSIZE - 1;\n        wp &= WSIZE - 1;\n        buff[off + n++] = slide[wp++] = slide[copy_dist++];\n      }\n      if (n === size) {\n        return size;\n      }\n    }\n    method = -1; // done\n    return n;\n  }\n  function inflate_stored(buff, off, size) {\n    /* \"decompress\" an inflated type 0 (stored) block. */\n    var n;\n\n    // go to byte boundary\n    n = bit_len & 7;\n    DUMPBITS(n);\n\n    // get the length and its complement\n    NEEDBITS(16);\n    n = GETBITS(16);\n    DUMPBITS(16);\n    NEEDBITS(16);\n    if (n !== (~bit_buf & 0xffff)) {\n      return -1; // error in compressed data\n    }\n\n    DUMPBITS(16);\n\n    // read and output the compressed data\n    copy_leng = n;\n    n = 0;\n    while (copy_leng > 0 && n < size) {\n      copy_leng--;\n      wp &= WSIZE - 1;\n      NEEDBITS(8);\n      buff[off + n++] = slide[wp++] = GETBITS(8);\n      DUMPBITS(8);\n    }\n    if (copy_leng === 0) {\n      method = -1; // done\n    }\n\n    return n;\n  }\n  function inflate_fixed(buff, off, size) {\n    // decompress an inflated type 1 (fixed Huffman codes) block.  We should\n    // either replace this with a custom decoder, or at least precompute the\n    // Huffman tables.\n\n    // if first time, set up tables for fixed blocks\n    if (!fixed_tl) {\n      var i; // temporary variable\n      var l = []; // 288 length list for huft_build (initialized below)\n      var h; // HuftBuild\n\n      // literal table\n      for (i = 0; i < 144; i++) {\n        l[i] = 8;\n      }\n      for (null; i < 256; i++) {\n        l[i] = 9;\n      }\n      for (null; i < 280; i++) {\n        l[i] = 7;\n      }\n      for (null; i < 288; i++) {\n        // make a complete, but wrong code set\n        l[i] = 8;\n      }\n      fixed_bl = 7;\n      h = new HuftBuild(l, 288, 257, cplens, cplext, fixed_bl);\n      if (h.status !== 0) {\n        console.error(\"HufBuild error: \" + h.status);\n        return -1;\n      }\n      fixed_tl = h.root;\n      fixed_bl = h.m;\n\n      // distance table\n      for (i = 0; i < 30; i++) {\n        // make an incomplete code set\n        l[i] = 5;\n      }\n      fixed_bd = 5;\n      h = new HuftBuild(l, 30, 0, cpdist, cpdext, fixed_bd);\n      if (h.status > 1) {\n        fixed_tl = null;\n        console.error(\"HufBuild error: \" + h.status);\n        return -1;\n      }\n      fixed_td = h.root;\n      fixed_bd = h.m;\n    }\n    tl = fixed_tl;\n    td = fixed_td;\n    bl = fixed_bl;\n    bd = fixed_bd;\n    return inflate_codes(buff, off, size);\n  }\n  function inflate_dynamic(buff, off, size) {\n    // decompress an inflated type 2 (dynamic Huffman codes) block.\n    var i; // temporary variables\n    var j;\n    var l; // last length\n    var n; // number of lengths to get\n    var t; // (HuftNode) literal/length code table\n    var nb; // number of bit length codes\n    var nl; // number of literal/length codes\n    var nd; // number of distance codes\n    var ll = [];\n    var h; // (HuftBuild)\n\n    // literal/length and distance code lengths\n    for (i = 0; i < 286 + 30; i++) {\n      ll[i] = 0;\n    }\n\n    // read in table lengths\n    NEEDBITS(5);\n    nl = 257 + GETBITS(5); // number of literal/length codes\n    DUMPBITS(5);\n    NEEDBITS(5);\n    nd = 1 + GETBITS(5); // number of distance codes\n    DUMPBITS(5);\n    NEEDBITS(4);\n    nb = 4 + GETBITS(4); // number of bit length codes\n    DUMPBITS(4);\n    if (nl > 286 || nd > 30) {\n      return -1; // bad lengths\n    }\n\n    // read in bit-length-code lengths\n    for (j = 0; j < nb; j++) {\n      NEEDBITS(3);\n      ll[border[j]] = GETBITS(3);\n      DUMPBITS(3);\n    }\n    for (null; j < 19; j++) {\n      ll[border[j]] = 0;\n    }\n\n    // build decoding table for trees--single level, 7 bit lookup\n    bl = 7;\n    h = new HuftBuild(ll, 19, 19, null, null, bl);\n    if (h.status !== 0) {\n      return -1; // incomplete code set\n    }\n\n    tl = h.root;\n    bl = h.m;\n\n    // read in literal and distance code lengths\n    n = nl + nd;\n    i = l = 0;\n    while (i < n) {\n      NEEDBITS(bl);\n      t = tl.list[GETBITS(bl)];\n      j = t.b;\n      DUMPBITS(j);\n      j = t.n;\n      if (j < 16) {\n        // length of code in bits (0..15)\n        ll[i++] = l = j; // save last length in l\n      } else if (j === 16) {\n        // repeat last length 3 to 6 times\n        NEEDBITS(2);\n        j = 3 + GETBITS(2);\n        DUMPBITS(2);\n        if (i + j > n) {\n          return -1;\n        }\n        while (j-- > 0) {\n          ll[i++] = l;\n        }\n      } else if (j === 17) {\n        // 3 to 10 zero length codes\n        NEEDBITS(3);\n        j = 3 + GETBITS(3);\n        DUMPBITS(3);\n        if (i + j > n) {\n          return -1;\n        }\n        while (j-- > 0) {\n          ll[i++] = 0;\n        }\n        l = 0;\n      } else {\n        // j === 18: 11 to 138 zero length codes\n        NEEDBITS(7);\n        j = 11 + GETBITS(7);\n        DUMPBITS(7);\n        if (i + j > n) {\n          return -1;\n        }\n        while (j-- > 0) {\n          ll[i++] = 0;\n        }\n        l = 0;\n      }\n    }\n\n    // build the decoding tables for literal/length and distance codes\n    bl = lbits;\n    h = new HuftBuild(ll, nl, 257, cplens, cplext, bl);\n    if (bl === 0) {\n      // no literals or lengths\n      h.status = 1;\n    }\n    if (h.status !== 0) {\n      if (h.status !== 1) {\n        return -1; // incomplete code set\n      }\n      // **incomplete literal tree**\n    }\n\n    tl = h.root;\n    bl = h.m;\n    for (i = 0; i < nd; i++) {\n      ll[i] = ll[i + nl];\n    }\n    bd = dbits;\n    h = new HuftBuild(ll, nd, 0, cpdist, cpdext, bd);\n    td = h.root;\n    bd = h.m;\n    if (bd === 0 && nl > 257) {\n      // lengths but no distances\n      // **incomplete distance tree**\n      return -1;\n    }\n    /*\n    \t\tif (h.status === 1) {\n    \t\t\t// **incomplete distance tree**\n    \t\t}\n    */\n    if (h.status !== 0) {\n      return -1;\n    }\n\n    // decompress until an end-of-block code\n    return inflate_codes(buff, off, size);\n  }\n  function inflate_start() {\n    if (!slide) {\n      slide = []; // new Array(2 * WSIZE); // slide.length is never called\n    }\n\n    wp = 0;\n    bit_buf = 0;\n    bit_len = 0;\n    method = -1;\n    eof = false;\n    copy_leng = copy_dist = 0;\n    tl = null;\n  }\n  function inflate_internal(buff, off, size) {\n    // decompress an inflated entry\n    var n, i;\n    n = 0;\n    while (n < size) {\n      if (eof && method === -1) {\n        return n;\n      }\n      if (copy_leng > 0) {\n        if (method !== STORED_BLOCK) {\n          // STATIC_TREES or DYN_TREES\n          while (copy_leng > 0 && n < size) {\n            copy_leng--;\n            copy_dist &= WSIZE - 1;\n            wp &= WSIZE - 1;\n            buff[off + n++] = slide[wp++] = slide[copy_dist++];\n          }\n        } else {\n          while (copy_leng > 0 && n < size) {\n            copy_leng--;\n            wp &= WSIZE - 1;\n            NEEDBITS(8);\n            buff[off + n++] = slide[wp++] = GETBITS(8);\n            DUMPBITS(8);\n          }\n          if (copy_leng === 0) {\n            method = -1; // done\n          }\n        }\n\n        if (n === size) {\n          return n;\n        }\n      }\n      if (method === -1) {\n        if (eof) {\n          break;\n        }\n\n        // read in last block bit\n        NEEDBITS(1);\n        if (GETBITS(1) !== 0) {\n          eof = true;\n        }\n        DUMPBITS(1);\n\n        // read in block type\n        NEEDBITS(2);\n        method = GETBITS(2);\n        DUMPBITS(2);\n        tl = null;\n        copy_leng = 0;\n      }\n      switch (method) {\n        case STORED_BLOCK:\n          i = inflate_stored(buff, off + n, size - n);\n          break;\n        case STATIC_TREES:\n          if (tl) {\n            i = inflate_codes(buff, off + n, size - n);\n          } else {\n            i = inflate_fixed(buff, off + n, size - n);\n          }\n          break;\n        case DYN_TREES:\n          if (tl) {\n            i = inflate_codes(buff, off + n, size - n);\n          } else {\n            i = inflate_dynamic(buff, off + n, size - n);\n          }\n          break;\n        default:\n          // error\n          i = -1;\n          break;\n      }\n      if (i === -1) {\n        if (eof) {\n          return 0;\n        }\n        return -1;\n      }\n      n += i;\n    }\n    return n;\n  }\n  function inflate(arr) {\n    var buff = [],\n      i;\n    inflate_start();\n    inflate_data = arr;\n    inflate_pos = 0;\n    do {\n      i = inflate_internal(buff, buff.length, 1024);\n    } while (i > 0);\n    inflate_data = null; // G.C.\n    return buff;\n  }\n  module.exports = inflate;\n})();","map":{"version":3,"names":["WSIZE","STORED_BLOCK","STATIC_TREES","DYN_TREES","lbits","dbits","slide","wp","fixed_tl","fixed_td","fixed_bl","fixed_bd","bit_buf","bit_len","method","eof","copy_leng","copy_dist","tl","td","bl","bd","inflate_data","inflate_pos","MASK_BITS","cplens","cplext","cpdist","cpdext","border","HuftList","next","list","HuftNode","e","b","n","t","HuftBuild","s","d","mm","BMAX","N_MAX","status","root","m","a","c","el","f","g","h","i","j","k","lx","p","pidx","q","r","u","v","w","x","xp","y","z","o","tail","GET_BYTE","length","NEEDBITS","GETBITS","DUMPBITS","inflate_codes","buff","off","size","inflate_stored","inflate_fixed","l","console","error","inflate_dynamic","nb","nl","nd","ll","inflate_start","inflate_internal","inflate","arr","module","exports"],"sources":["/Users/Philip/githome/plant-uml-client/node_modules/deflate-js/lib/rawinflate.js"],"sourcesContent":["/*\n * $Id: rawinflate.js,v 0.2 2009/03/01 18:32:24 dankogai Exp $\n *\n * original:\n * http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt\n */\n\n/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0.0.1\n * LastModified: Dec 25 1999\n */\n\n/* Interface:\n * data = inflate(src);\n */\n\n(function () {\n\t/* constant parameters */\n\tvar WSIZE = 32768, // Sliding Window size\n\t\tSTORED_BLOCK = 0,\n\t\tSTATIC_TREES = 1,\n\t\tDYN_TREES = 2,\n\n\t/* for inflate */\n\t\tlbits = 9, // bits in base literal/length lookup table\n\t\tdbits = 6, // bits in base distance lookup table\n\n\t/* variables (inflate) */\n\t\tslide,\n\t\twp, // current position in slide\n\t\tfixed_tl = null, // inflate static\n\t\tfixed_td, // inflate static\n\t\tfixed_bl, // inflate static\n\t\tfixed_bd, // inflate static\n\t\tbit_buf, // bit buffer\n\t\tbit_len, // bits in bit buffer\n\t\tmethod,\n\t\teof,\n\t\tcopy_leng,\n\t\tcopy_dist,\n\t\ttl, // literal length decoder table\n\t\ttd, // literal distance decoder table\n\t\tbl, // number of bits decoded by tl\n\t\tbd, // number of bits decoded by td\n\n\t\tinflate_data,\n\t\tinflate_pos,\n\n\n/* constant tables (inflate) */\n\t\tMASK_BITS = [\n\t\t\t0x0000,\n\t\t\t0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,\n\t\t\t0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff\n\t\t],\n\t\t// Tables for deflate from PKZIP's appnote.txt.\n\t\t// Copy lengths for literal codes 257..285\n\t\tcplens = [\n\t\t\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n\t\t\t35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n\t\t],\n/* note: see note #13 above about the 258 in this list. */\n\t\t// Extra bits for literal codes 257..285\n\t\tcplext = [\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99 // 99==invalid\n\t\t],\n\t\t// Copy offsets for distance codes 0..29\n\t\tcpdist = [\n\t\t\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n\t\t\t257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n\t\t\t8193, 12289, 16385, 24577\n\t\t],\n\t\t// Extra bits for distance codes\n\t\tcpdext = [\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n\t\t\t12, 12, 13, 13\n\t\t],\n\t\t// Order of the bit length code lengths\n\t\tborder = [\n\t\t\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15\n\t\t];\n\t/* objects (inflate) */\n\n\tfunction HuftList() {\n\t\tthis.next = null;\n\t\tthis.list = null;\n\t}\n\n\tfunction HuftNode() {\n\t\tthis.e = 0; // number of extra bits or operation\n\t\tthis.b = 0; // number of bits in this code or subcode\n\n\t\t// union\n\t\tthis.n = 0; // literal, length base, or distance base\n\t\tthis.t = null; // (HuftNode) pointer to next level of table\n\t}\n\n\t/*\n\t * @param b-  code lengths in bits (all assumed <= BMAX)\n\t * @param n- number of codes (assumed <= N_MAX)\n\t * @param s- number of simple-valued codes (0..s-1)\n\t * @param d- list of base values for non-simple codes\n\t * @param e- list of extra bits for non-simple codes\n\t * @param mm- maximum lookup bits\n\t */\n\tfunction HuftBuild(b, n, s, d, e, mm) {\n\t\tthis.BMAX = 16; // maximum bit length of any code\n\t\tthis.N_MAX = 288; // maximum number of codes in any set\n\t\tthis.status = 0; // 0: success, 1: incomplete table, 2: bad input\n\t\tthis.root = null; // (HuftList) starting table\n\t\tthis.m = 0; // maximum lookup bits, returns actual\n\n\t/* Given a list of code lengths and a maximum table size, make a set of\n\t   tables to decode that set of codes. Return zero on success, one if\n\t   the given code set is incomplete (the tables are still built in this\n\t   case), two if the input is invalid (all zero length codes or an\n\t   oversubscribed set of lengths), and three if not enough memory.\n\t   The code with value 256 is special, and the tables are constructed\n\t   so that no bits beyond that code are fetched when that code is\n\t   decoded. */\n\t\tvar a; // counter for codes of length k\n\t\tvar c = [];\n\t\tvar el; // length of EOB code (value 256)\n\t\tvar f; // i repeats in table every f entries\n\t\tvar g; // maximum code length\n\t\tvar h; // table level\n\t\tvar i; // counter, current code\n\t\tvar j; // counter\n\t\tvar k; // number of bits in current code\n\t\tvar lx = [];\n\t\tvar p; // pointer into c[], b[], or v[]\n\t\tvar pidx; // index of p\n\t\tvar q; // (HuftNode) points to current table\n\t\tvar r = new HuftNode(); // table entry for structure assignment\n\t\tvar u = [];\n\t\tvar v = [];\n\t\tvar w;\n\t\tvar x = [];\n\t\tvar xp; // pointer into x or c\n\t\tvar y; // number of dummy codes added\n\t\tvar z; // number of entries in current table\n\t\tvar o;\n\t\tvar tail; // (HuftList)\n\n\t\ttail = this.root = null;\n\n\t\t// bit length count table\n\t\tfor (i = 0; i < this.BMAX + 1; i++) {\n\t\t\tc[i] = 0;\n\t\t}\n\t\t// stack of bits per table\n\t\tfor (i = 0; i < this.BMAX + 1; i++) {\n\t\t\tlx[i] = 0;\n\t\t}\n\t\t// HuftNode[BMAX][]  table stack\n\t\tfor (i = 0; i < this.BMAX; i++) {\n\t\t\tu[i] = null;\n\t\t}\n\t\t// values in order of bit length\n\t\tfor (i = 0; i < this.N_MAX; i++) {\n\t\t\tv[i] = 0;\n\t\t}\n\t\t// bit offsets, then code stack\n\t\tfor (i = 0; i < this.BMAX + 1; i++) {\n\t\t\tx[i] = 0;\n\t\t}\n\n\t\t// Generate counts for each bit length\n\t\tel = n > 256 ? b[256] : this.BMAX; // set length of EOB code, if any\n\t\tp = b; pidx = 0;\n\t\ti = n;\n\t\tdo {\n\t\t\tc[p[pidx]]++; // assume all entries <= BMAX\n\t\t\tpidx++;\n\t\t} while (--i > 0);\n\t\tif (c[0] === n) { // null input--all zero length codes\n\t\t\tthis.root = null;\n\t\t\tthis.m = 0;\n\t\t\tthis.status = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t// Find minimum and maximum length, bound *m by those\n\t\tfor (j = 1; j <= this.BMAX; j++) {\n\t\t\tif (c[j] !== 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tk = j; // minimum code length\n\t\tif (mm < j) {\n\t\t\tmm = j;\n\t\t}\n\t\tfor (i = this.BMAX; i !== 0; i--) {\n\t\t\tif (c[i] !== 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tg = i; // maximum code length\n\t\tif (mm > i) {\n\t\t\tmm = i;\n\t\t}\n\n\t\t// Adjust last length count to fill out codes, if needed\n\t\tfor (y = 1 << j; j < i; j++, y <<= 1) {\n\t\t\tif ((y -= c[j]) < 0) {\n\t\t\t\tthis.status = 2; // bad input: more codes than bits\n\t\t\t\tthis.m = mm;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif ((y -= c[i]) < 0) {\n\t\t\tthis.status = 2;\n\t\t\tthis.m = mm;\n\t\t\treturn;\n\t\t}\n\t\tc[i] += y;\n\n\t\t// Generate starting offsets into the value table for each length\n\t\tx[1] = j = 0;\n\t\tp = c;\n\t\tpidx = 1;\n\t\txp = 2;\n\t\twhile (--i > 0) { // note that i == g from above\n\t\t\tx[xp++] = (j += p[pidx++]);\n\t\t}\n\n\t\t// Make a table of values in order of bit lengths\n\t\tp = b; pidx = 0;\n\t\ti = 0;\n\t\tdo {\n\t\t\tif ((j = p[pidx++]) !== 0) {\n\t\t\t\tv[x[j]++] = i;\n\t\t\t}\n\t\t} while (++i < n);\n\t\tn = x[g]; // set n to length of v\n\n\t\t// Generate the Huffman codes and for each, make the table entries\n\t\tx[0] = i = 0; // first Huffman code is zero\n\t\tp = v; pidx = 0; // grab values in bit order\n\t\th = -1; // no tables yet--level -1\n\t\tw = lx[0] = 0; // no bits decoded yet\n\t\tq = null; // ditto\n\t\tz = 0; // ditto\n\n\t\t// go through the bit lengths (k already is bits in shortest code)\n\t\tfor (null; k <= g; k++) {\n\t\t\ta = c[k];\n\t\t\twhile (a-- > 0) {\n\t\t\t\t// here i is the Huffman code of length k bits for value p[pidx]\n\t\t\t\t// make tables up to required level\n\t\t\t\twhile (k > w + lx[1 + h]) {\n\t\t\t\t\tw += lx[1 + h]; // add bits already decoded\n\t\t\t\t\th++;\n\n\t\t\t\t\t// compute minimum size table less than or equal to *m bits\n\t\t\t\t\tz = (z = g - w) > mm ? mm : z; // upper limit\n\t\t\t\t\tif ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table\n\t\t\t\t\t\t// too few codes for k-w bit table\n\t\t\t\t\t\tf -= a + 1; // deduct codes from patterns left\n\t\t\t\t\t\txp = k;\n\t\t\t\t\t\twhile (++j < z) { // try smaller tables up to z bits\n\t\t\t\t\t\t\tif ((f <<= 1) <= c[++xp]) {\n\t\t\t\t\t\t\t\tbreak; // enough codes to use up j bits\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf -= c[xp]; // else deduct codes from patterns\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (w + j > el && w < el) {\n\t\t\t\t\t\tj = el - w; // make EOB code end at table\n\t\t\t\t\t}\n\t\t\t\t\tz = 1 << j; // table entries for j-bit table\n\t\t\t\t\tlx[1 + h] = j; // set table size in stack\n\n\t\t\t\t\t// allocate and link in new table\n\t\t\t\t\tq = [];\n\t\t\t\t\tfor (o = 0; o < z; o++) {\n\t\t\t\t\t\tq[o] = new HuftNode();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!tail) {\n\t\t\t\t\t\ttail = this.root = new HuftList();\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttail = tail.next = new HuftList();\n\t\t\t\t\t}\n\t\t\t\t\ttail.next = null;\n\t\t\t\t\ttail.list = q;\n\t\t\t\t\tu[h] = q; // table starts after link\n\n\t\t\t\t\t/* connect to last table, if there is one */\n\t\t\t\t\tif (h > 0) {\n\t\t\t\t\t\tx[h] = i; // save pattern for backing up\n\t\t\t\t\t\tr.b = lx[h]; // bits to dump before this table\n\t\t\t\t\t\tr.e = 16 + j; // bits in this table\n\t\t\t\t\t\tr.t = q; // pointer to this table\n\t\t\t\t\t\tj = (i & ((1 << w) - 1)) >> (w - lx[h]);\n\t\t\t\t\t\tu[h - 1][j].e = r.e;\n\t\t\t\t\t\tu[h - 1][j].b = r.b;\n\t\t\t\t\t\tu[h - 1][j].n = r.n;\n\t\t\t\t\t\tu[h - 1][j].t = r.t;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// set up table entry in r\n\t\t\t\tr.b = k - w;\n\t\t\t\tif (pidx >= n) {\n\t\t\t\t\tr.e = 99; // out of values--invalid code\n\t\t\t\t} else if (p[pidx] < s) {\n\t\t\t\t\tr.e = (p[pidx] < 256 ? 16 : 15); // 256 is end-of-block code\n\t\t\t\t\tr.n = p[pidx++]; // simple code is just the value\n\t\t\t\t} else {\n\t\t\t\t\tr.e = e[p[pidx] - s]; // non-simple--look up in lists\n\t\t\t\t\tr.n = d[p[pidx++] - s];\n\t\t\t\t}\n\n\t\t\t\t// fill code-like entries with r //\n\t\t\t\tf = 1 << (k - w);\n\t\t\t\tfor (j = i >> w; j < z; j += f) {\n\t\t\t\t\tq[j].e = r.e;\n\t\t\t\t\tq[j].b = r.b;\n\t\t\t\t\tq[j].n = r.n;\n\t\t\t\t\tq[j].t = r.t;\n\t\t\t\t}\n\n\t\t\t\t// backwards increment the k-bit code i\n\t\t\t\tfor (j = 1 << (k - 1); (i & j) !== 0; j >>= 1) {\n\t\t\t\t\ti ^= j;\n\t\t\t\t}\n\t\t\t\ti ^= j;\n\n\t\t\t\t// backup over finished tables\n\t\t\t\twhile ((i & ((1 << w) - 1)) !== x[h]) {\n\t\t\t\t\tw -= lx[h]; // don't need to update q\n\t\t\t\t\th--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* return actual size of base table */\n\t\tthis.m = lx[1];\n\n\t\t/* Return true (1) if we were given an incomplete table */\n\t\tthis.status = ((y !== 0 && g !== 1) ? 1 : 0);\n\t}\n\n\n\t/* routines (inflate) */\n\n\tfunction GET_BYTE() {\n\t\tif (inflate_data.length === inflate_pos) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn inflate_data[inflate_pos++] & 0xff;\n\t}\n\n\tfunction NEEDBITS(n) {\n\t\twhile (bit_len < n) {\n\t\t\tbit_buf |= GET_BYTE() << bit_len;\n\t\t\tbit_len += 8;\n\t\t}\n\t}\n\n\tfunction GETBITS(n) {\n\t\treturn bit_buf & MASK_BITS[n];\n\t}\n\n\tfunction DUMPBITS(n) {\n\t\tbit_buf >>= n;\n\t\tbit_len -= n;\n\t}\n\n\tfunction inflate_codes(buff, off, size) {\n\t\t// inflate (decompress) the codes in a deflated (compressed) block.\n\t\t// Return an error code or zero if it all goes ok.\n\t\tvar e; // table entry flag/number of extra bits\n\t\tvar t; // (HuftNode) pointer to table entry\n\t\tvar n;\n\n\t\tif (size === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// inflate the coded data\n\t\tn = 0;\n\t\tfor (;;) { // do until end of block\n\t\t\tNEEDBITS(bl);\n\t\t\tt = tl.list[GETBITS(bl)];\n\t\t\te = t.e;\n\t\t\twhile (e > 16) {\n\t\t\t\tif (e === 99) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tDUMPBITS(t.b);\n\t\t\t\te -= 16;\n\t\t\t\tNEEDBITS(e);\n\t\t\t\tt = t.t[GETBITS(e)];\n\t\t\t\te = t.e;\n\t\t\t}\n\t\t\tDUMPBITS(t.b);\n\n\t\t\tif (e === 16) { // then it's a literal\n\t\t\t\twp &= WSIZE - 1;\n\t\t\t\tbuff[off + n++] = slide[wp++] = t.n;\n\t\t\t\tif (n === size) {\n\t\t\t\t\treturn size;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// exit if end of block\n\t\t\tif (e === 15) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// it's an EOB or a length\n\n\t\t\t// get length of block to copy\n\t\t\tNEEDBITS(e);\n\t\t\tcopy_leng = t.n + GETBITS(e);\n\t\t\tDUMPBITS(e);\n\n\t\t\t// decode distance of block to copy\n\t\t\tNEEDBITS(bd);\n\t\t\tt = td.list[GETBITS(bd)];\n\t\t\te = t.e;\n\n\t\t\twhile (e > 16) {\n\t\t\t\tif (e === 99) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tDUMPBITS(t.b);\n\t\t\t\te -= 16;\n\t\t\t\tNEEDBITS(e);\n\t\t\t\tt = t.t[GETBITS(e)];\n\t\t\t\te = t.e;\n\t\t\t}\n\t\t\tDUMPBITS(t.b);\n\t\t\tNEEDBITS(e);\n\t\t\tcopy_dist = wp - t.n - GETBITS(e);\n\t\t\tDUMPBITS(e);\n\n\t\t\t// do the copy\n\t\t\twhile (copy_leng > 0 && n < size) {\n\t\t\t\tcopy_leng--;\n\t\t\t\tcopy_dist &= WSIZE - 1;\n\t\t\t\twp &= WSIZE - 1;\n\t\t\t\tbuff[off + n++] = slide[wp++] = slide[copy_dist++];\n\t\t\t}\n\n\t\t\tif (n === size) {\n\t\t\t\treturn size;\n\t\t\t}\n\t\t}\n\n\t\tmethod = -1; // done\n\t\treturn n;\n\t}\n\n\tfunction inflate_stored(buff, off, size) {\n\t\t/* \"decompress\" an inflated type 0 (stored) block. */\n\t\tvar n;\n\n\t\t// go to byte boundary\n\t\tn = bit_len & 7;\n\t\tDUMPBITS(n);\n\n\t\t// get the length and its complement\n\t\tNEEDBITS(16);\n\t\tn = GETBITS(16);\n\t\tDUMPBITS(16);\n\t\tNEEDBITS(16);\n\t\tif (n !== ((~bit_buf) & 0xffff)) {\n\t\t\treturn -1; // error in compressed data\n\t\t}\n\t\tDUMPBITS(16);\n\n\t\t// read and output the compressed data\n\t\tcopy_leng = n;\n\n\t\tn = 0;\n\t\twhile (copy_leng > 0 && n < size) {\n\t\t\tcopy_leng--;\n\t\t\twp &= WSIZE - 1;\n\t\t\tNEEDBITS(8);\n\t\t\tbuff[off + n++] = slide[wp++] = GETBITS(8);\n\t\t\tDUMPBITS(8);\n\t\t}\n\n\t\tif (copy_leng === 0) {\n\t\t\tmethod = -1; // done\n\t\t}\n\t\treturn n;\n\t}\n\n\tfunction inflate_fixed(buff, off, size) {\n\t\t// decompress an inflated type 1 (fixed Huffman codes) block.  We should\n\t\t// either replace this with a custom decoder, or at least precompute the\n\t\t// Huffman tables.\n\n\t\t// if first time, set up tables for fixed blocks\n\t\tif (!fixed_tl) {\n\t\t\tvar i; // temporary variable\n\t\t\tvar l = []; // 288 length list for huft_build (initialized below)\n\t\t\tvar h; // HuftBuild\n\n\t\t\t// literal table\n\t\t\tfor (i = 0; i < 144; i++) {\n\t\t\t\tl[i] = 8;\n\t\t\t}\n\t\t\tfor (null; i < 256; i++) {\n\t\t\t\tl[i] = 9;\n\t\t\t}\n\t\t\tfor (null; i < 280; i++) {\n\t\t\t\tl[i] = 7;\n\t\t\t}\n\t\t\tfor (null; i < 288; i++) { // make a complete, but wrong code set\n\t\t\t\tl[i] = 8;\n\t\t\t}\n\t\t\tfixed_bl = 7;\n\n\t\t\th = new HuftBuild(l, 288, 257, cplens, cplext, fixed_bl);\n\t\t\tif (h.status !== 0) {\n\t\t\t\tconsole.error(\"HufBuild error: \" + h.status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfixed_tl = h.root;\n\t\t\tfixed_bl = h.m;\n\n\t\t\t// distance table\n\t\t\tfor (i = 0; i < 30; i++) { // make an incomplete code set\n\t\t\t\tl[i] = 5;\n\t\t\t}\n\t\t\tfixed_bd = 5;\n\n\t\t\th = new HuftBuild(l, 30, 0, cpdist, cpdext, fixed_bd);\n\t\t\tif (h.status > 1) {\n\t\t\t\tfixed_tl = null;\n\t\t\t\tconsole.error(\"HufBuild error: \" + h.status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfixed_td = h.root;\n\t\t\tfixed_bd = h.m;\n\t\t}\n\n\t\ttl = fixed_tl;\n\t\ttd = fixed_td;\n\t\tbl = fixed_bl;\n\t\tbd = fixed_bd;\n\t\treturn inflate_codes(buff, off, size);\n\t}\n\n\tfunction inflate_dynamic(buff, off, size) {\n\t\t// decompress an inflated type 2 (dynamic Huffman codes) block.\n\t\tvar i; // temporary variables\n\t\tvar j;\n\t\tvar l; // last length\n\t\tvar n; // number of lengths to get\n\t\tvar t; // (HuftNode) literal/length code table\n\t\tvar nb; // number of bit length codes\n\t\tvar nl; // number of literal/length codes\n\t\tvar nd; // number of distance codes\n\t\tvar ll = [];\n\t\tvar h; // (HuftBuild)\n\n\t\t// literal/length and distance code lengths\n\t\tfor (i = 0; i < 286 + 30; i++) {\n\t\t\tll[i] = 0;\n\t\t}\n\n\t\t// read in table lengths\n\t\tNEEDBITS(5);\n\t\tnl = 257 + GETBITS(5); // number of literal/length codes\n\t\tDUMPBITS(5);\n\t\tNEEDBITS(5);\n\t\tnd = 1 + GETBITS(5); // number of distance codes\n\t\tDUMPBITS(5);\n\t\tNEEDBITS(4);\n\t\tnb = 4 + GETBITS(4); // number of bit length codes\n\t\tDUMPBITS(4);\n\t\tif (nl > 286 || nd > 30) {\n\t\t\treturn -1; // bad lengths\n\t\t}\n\n\t\t// read in bit-length-code lengths\n\t\tfor (j = 0; j < nb; j++) {\n\t\t\tNEEDBITS(3);\n\t\t\tll[border[j]] = GETBITS(3);\n\t\t\tDUMPBITS(3);\n\t\t}\n\t\tfor (null; j < 19; j++) {\n\t\t\tll[border[j]] = 0;\n\t\t}\n\n\t\t// build decoding table for trees--single level, 7 bit lookup\n\t\tbl = 7;\n\t\th = new HuftBuild(ll, 19, 19, null, null, bl);\n\t\tif (h.status !== 0) {\n\t\t\treturn -1; // incomplete code set\n\t\t}\n\n\t\ttl = h.root;\n\t\tbl = h.m;\n\n\t\t// read in literal and distance code lengths\n\t\tn = nl + nd;\n\t\ti = l = 0;\n\t\twhile (i < n) {\n\t\t\tNEEDBITS(bl);\n\t\t\tt = tl.list[GETBITS(bl)];\n\t\t\tj = t.b;\n\t\t\tDUMPBITS(j);\n\t\t\tj = t.n;\n\t\t\tif (j < 16) { // length of code in bits (0..15)\n\t\t\t\tll[i++] = l = j; // save last length in l\n\t\t\t} else if (j === 16) { // repeat last length 3 to 6 times\n\t\t\t\tNEEDBITS(2);\n\t\t\t\tj = 3 + GETBITS(2);\n\t\t\t\tDUMPBITS(2);\n\t\t\t\tif (i + j > n) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\twhile (j-- > 0) {\n\t\t\t\t\tll[i++] = l;\n\t\t\t\t}\n\t\t\t} else if (j === 17) { // 3 to 10 zero length codes\n\t\t\t\tNEEDBITS(3);\n\t\t\t\tj = 3 + GETBITS(3);\n\t\t\t\tDUMPBITS(3);\n\t\t\t\tif (i + j > n) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\twhile (j-- > 0) {\n\t\t\t\t\tll[i++] = 0;\n\t\t\t\t}\n\t\t\t\tl = 0;\n\t\t\t} else { // j === 18: 11 to 138 zero length codes\n\t\t\t\tNEEDBITS(7);\n\t\t\t\tj = 11 + GETBITS(7);\n\t\t\t\tDUMPBITS(7);\n\t\t\t\tif (i + j > n) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\twhile (j-- > 0) {\n\t\t\t\t\tll[i++] = 0;\n\t\t\t\t}\n\t\t\t\tl = 0;\n\t\t\t}\n\t\t}\n\n\t\t// build the decoding tables for literal/length and distance codes\n\t\tbl = lbits;\n\t\th = new HuftBuild(ll, nl, 257, cplens, cplext, bl);\n\t\tif (bl === 0) { // no literals or lengths\n\t\t\th.status = 1;\n\t\t}\n\t\tif (h.status !== 0) {\n\t\t\tif (h.status !== 1) {\n\t\t\t\treturn -1; // incomplete code set\n\t\t\t}\n\t\t\t// **incomplete literal tree**\n\t\t}\n\t\ttl = h.root;\n\t\tbl = h.m;\n\n\t\tfor (i = 0; i < nd; i++) {\n\t\t\tll[i] = ll[i + nl];\n\t\t}\n\t\tbd = dbits;\n\t\th = new HuftBuild(ll, nd, 0, cpdist, cpdext, bd);\n\t\ttd = h.root;\n\t\tbd = h.m;\n\n\t\tif (bd === 0 && nl > 257) { // lengths but no distances\n\t\t\t// **incomplete distance tree**\n\t\t\treturn -1;\n\t\t}\n/*\n\t\tif (h.status === 1) {\n\t\t\t// **incomplete distance tree**\n\t\t}\n*/\n\t\tif (h.status !== 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// decompress until an end-of-block code\n\t\treturn inflate_codes(buff, off, size);\n\t}\n\n\tfunction inflate_start() {\n\t\tif (!slide) {\n\t\t\tslide = []; // new Array(2 * WSIZE); // slide.length is never called\n\t\t}\n\t\twp = 0;\n\t\tbit_buf = 0;\n\t\tbit_len = 0;\n\t\tmethod = -1;\n\t\teof = false;\n\t\tcopy_leng = copy_dist = 0;\n\t\ttl = null;\n\t}\n\n\tfunction inflate_internal(buff, off, size) {\n\t\t// decompress an inflated entry\n\t\tvar n, i;\n\n\t\tn = 0;\n\t\twhile (n < size) {\n\t\t\tif (eof && method === -1) {\n\t\t\t\treturn n;\n\t\t\t}\n\n\t\t\tif (copy_leng > 0) {\n\t\t\t\tif (method !== STORED_BLOCK) {\n\t\t\t\t\t// STATIC_TREES or DYN_TREES\n\t\t\t\t\twhile (copy_leng > 0 && n < size) {\n\t\t\t\t\t\tcopy_leng--;\n\t\t\t\t\t\tcopy_dist &= WSIZE - 1;\n\t\t\t\t\t\twp &= WSIZE - 1;\n\t\t\t\t\t\tbuff[off + n++] = slide[wp++] = slide[copy_dist++];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (copy_leng > 0 && n < size) {\n\t\t\t\t\t\tcopy_leng--;\n\t\t\t\t\t\twp &= WSIZE - 1;\n\t\t\t\t\t\tNEEDBITS(8);\n\t\t\t\t\t\tbuff[off + n++] = slide[wp++] = GETBITS(8);\n\t\t\t\t\t\tDUMPBITS(8);\n\t\t\t\t\t}\n\t\t\t\t\tif (copy_leng === 0) {\n\t\t\t\t\t\tmethod = -1; // done\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (n === size) {\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (method === -1) {\n\t\t\t\tif (eof) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// read in last block bit\n\t\t\t\tNEEDBITS(1);\n\t\t\t\tif (GETBITS(1) !== 0) {\n\t\t\t\t\teof = true;\n\t\t\t\t}\n\t\t\t\tDUMPBITS(1);\n\n\t\t\t\t// read in block type\n\t\t\t\tNEEDBITS(2);\n\t\t\t\tmethod = GETBITS(2);\n\t\t\t\tDUMPBITS(2);\n\t\t\t\ttl = null;\n\t\t\t\tcopy_leng = 0;\n\t\t\t}\n\n\t\t\tswitch (method) {\n\t\t\tcase STORED_BLOCK:\n\t\t\t\ti = inflate_stored(buff, off + n, size - n);\n\t\t\t\tbreak;\n\n\t\t\tcase STATIC_TREES:\n\t\t\t\tif (tl) {\n\t\t\t\t\ti = inflate_codes(buff, off + n, size - n);\n\t\t\t\t} else {\n\t\t\t\t\ti = inflate_fixed(buff, off + n, size - n);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DYN_TREES:\n\t\t\t\tif (tl) {\n\t\t\t\t\ti = inflate_codes(buff, off + n, size - n);\n\t\t\t\t} else {\n\t\t\t\t\ti = inflate_dynamic(buff, off + n, size - n);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault: // error\n\t\t\t\ti = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i === -1) {\n\t\t\t\tif (eof) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tn += i;\n\t\t}\n\t\treturn n;\n\t}\n\n\tfunction inflate(arr) {\n\t\tvar buff = [], i;\n\n\t\tinflate_start();\n\t\tinflate_data = arr;\n\t\tinflate_pos = 0;\n\n\t\tdo {\n\t\t\ti = inflate_internal(buff, buff.length, 1024);\n\t\t} while (i > 0);\n\t\tinflate_data = null; // G.C.\n\t\treturn buff;\n\t}\n\n\tmodule.exports = inflate;\n}());\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}